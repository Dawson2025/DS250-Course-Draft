# Data Visualization

## Introduction

> "The simple graph has brought more information to the data analyst's mind than any other device." --- John Tukey

This chapter will teach you how to visualize your data using **[Plotly](https://plotly.com/python/)**.

There are broadly two categories of approach to using code to create data visualizations: imperative, where you build what you want, and declarative, where you say what you want. Choosing which to use involves a trade-off: imperative libraries offer you flexibility but at the cost of some verbosity; declarative libraries offer you a quick way to plot your data, but only if it’s in the right format to begin with, and customization to special chart types is more difficult. Python has many excellent plotting packages, including perhaps the most powerful imperative plotting package around, **matplotlib**.

However, we'll get further faster by learning one system and applying it in many places—and the beauty of declarative plotting is that it covers lots of standard charts simply and well. **Plotly** implements an imperative system with interactive features, making it suitable for a wide range of visualization needs.

We will start by creating a simple scatterplot and use that to introduce aesthetic mappings and geometric objects—the fundamental building blocks of **Plotly**. We will then walk you through visualizing distributions of single variables as well as visualizing relationships between two or more variables. We’ll finish off with saving your plots and troubleshooting tips.



### Prerequisites

You will need to install the **plotly** package for this chapter. To do this, open up the command line of your computer, type in `pip install plotly`, and hit enter.


```{note}
The command line can be opened within Visual Studio Code and Codespaces by going to View -> Terminal.
```

Note that you only need to install a package once in each Python environment.

We'll also need to have the **pandas** package installed—this package, which we'll be seeing a lot of, is for data. You can similarly install it by running `pip install pandas` on the command line.

Finally, we'll also need some data (you can't science without data). We'll be using the Palmer penguins dataset. Unusually, this can also be installed as a package—normally you would load data from a file, but these data are so popular for tutorials they've found their way into an installable package. Run `pip install palmerpenguins` to get these data.


Our next task is to load these into our Python session, either in a Python notebook cell within a Jupyter Notebook, by writing it in a script that we then send to the interactive window, or by typing it directly into the interactive window and hitting shift and enter. Here's the code:


```{python}
import pandas as pd
import plotly.express as px
from palmerpenguins import load_penguins
from numpy import polyfit

import plotly.express as px
import plotly.graph_objects as go
import seaborn as sns
import pandas as pd
from numpy import polyfit

import numpy as np

```


These lines import parts of the **pandas** and **palmerpenguins** packages, then import the **plotly.express** module as **px** for creating plots.


## First Steps

Do penguins with longer flippers weigh more or less than penguins with shorter flippers? You probably already have an answer, but try to make your answer precise. What does the relationship between flipper length and body mass look like? Is it positive? Negative? Linear? Nonlinear? Does the relationship vary by the species of the penguin? How about by the island where the penguin lives? Let’s create visualisations that we can use to answer these questions.



### The `penguins` data frame

You can test your answers to those questions with the penguins data frame found in palmerpenguins (a.k.a. `from palmerpenguins import load_penguins`). A data frame is a rectangular collection of variables (in the columns) and observations (in the rows). `penguins` contains 344 observations collected and made available by Dr. Kristen Gorman and the Palmer Station, Antarctica LTER.{cite:p}`horst2020palmerpenguins`.

To make the discussion easier, let's define some terms:

-   A **variable** is a quantity, quality, or property that you can measure.

-   A **value** is the state of a variable when you measure it.
    The value of a variable may change from measurement to measurement.

-   An **observation** is a set of measurements made under similar conditions (you usually make all of the measurements in an observation at the same time and on the same object).
    An observation will contain several values, each associated with a different variable.
    We'll sometimes refer to an observation as a data point.

-   **Tabular data** is a set of values, each associated with a variable and an observation.
    Tabular data is *tidy* if each value is placed in its own "cell", each variable in its own column, and each observation in its own row.

In this context, a variable refers to an attribute of all the penguins, and an observation refers to all the attributes of a single penguin.

Type the name of the data frame in the interactive window and Python will print a preview of its contents.



```{python}
penguins = load_penguins()
penguins
```


For an alternative view, where you can see the first few observations of each variable, use `penguins.head()`.


```{python}
penguins.head()
```




Among the variables in `penguins` are:

1.  `species`: a penguin's species (Adelie, Chinstrap, or Gentoo).

2.  `flipper_length_mm`: length of a penguin's flipper, in millimeters.

3.  `body_mass_g`: body mass of a penguin, in grams.

To learn more about `penguins`, open the help page of its data-loading function by running `help(load_penguins)`.



### Ultimate Goal

Our ultimate goal in this chapter is to recreate the following visualisation displaying the relationship between flipper lengths and body masses of these penguins, taking into consideration the species of the penguin.



```{python}
scatter_fig = px.scatter(
    penguins,
    x="flipper_length_mm",
    y="body_mass_g",
    color="species",
)


fit = polyfit(penguins["flipper_length_mm"].dropna(), penguins["body_mass_g"].dropna(), 1)
trendline = fit[0] * penguins["flipper_length_mm"] + fit[1]


trendline_fig = go.Scatter(
    x=penguins["flipper_length_mm"],
    y=trendline,
    mode='lines',
    name='Trendline'
)


scatter_fig.add_trace(trendline_fig)


scatter_fig.show()
```




### Creating a Plot
Let's recreate this plot step-by-step.

With Plotly, you begin a plot by defining the data and specifying how you want it to be visualized.

First, you need to import Plotly and your dataset. In this case, we'll use the penguins dataset.

```python
import plotly.express as px
import pandas as pd


penguins = pd.read_csv("path_to_penguins_dataset.csv")

```

Next, we'll create a basic scatter plot by mapping the `flipper_length_mm` to the `x-axis` and `body_mass_g` to the y-axis.


```python
fig = px.scatter(penguins, x='flipper_length_mm', y='body_mass_g', title='Scatterplot of Flipper Length vs. Body Mass')


fig.show()
```

In this example, the `px.scatter()` function is used to create a scatter plot. The data_frame argument specifies the dataset to use, and the `x` and `y` arguments define the variables to be plotted on the x and y axes, respectively. The `title` argument adds a title to the plot.

We can add more details and customize the plot further by adding layers such as color, size, and other aesthetics.

To map the `species` variable to the color aesthetic:

```Python
fig = px.scatter(penguins, x='flipper_length_mm', y='body_mass_g', color='species',
                 title='Scatterplot of Flipper Length vs. Body Mass Colored by Species')

fig.show()
```


```{python}
fig = px.scatter(
    penguins,
    x="flipper_length_mm",
    y="body_mass_g",
)

fig.show()
```

In Plotly, the `px.scatter()` function handles both the data mapping and the creation of the plot, making it straightforward to create complex visualizations with minimal code.


Now we have something that looks like what we might think of as a "scatterplot".
It doesn't yet match our "ultimate goal" plot, but using this plot we can start answering the question that motivated our exploration: "What does the relationship between flipper length and body mass look like?" The relationship appears to be positive (as flipper length increases, so does body mass), fairly linear (the points are clustered around a line instead of a curve), and moderately strong (there isn't too much scatter around such a line).
Penguins with longer flippers are generally larger in terms of their body mass.

It's a good point to flag that although we have plotted everything in the `penguins` data frame, there were a couple of rows with undefined values—and of course these cannot be plotted.




### Adding aesthetics and layers

Scatterplots are useful for displaying the relationship between two numerical variables, but it's always a good idea to be skeptical of any apparent relationship and ask if other variables might explain or change the nature of this relationship. For example, does the relationship between flipper length and body mass differ by species?

Let's incorporate species into our plot to see if this reveals any additional insights into the apparent relationship between these variables. We will do this by representing species with different colored points.

To achieve this, we need to modify the aesthetic mapping in the Plotly plot:



```{python}
import plotly.express as px

fig = px.scatter(
    penguins,
    x="flipper_length_mm",
    y="body_mass_g",
    color="species",
    title="Scatterplot of Flipper Length vs. Body Mass Colored by Species"
)

fig.show()

```


When a categorical variable is mapped to an aesthetic, Plotly automatically assigns a unique value of the aesthetic (here a unique color) to each unique level of the variable (each of the three species), a process known as **scaling**. Plotly also adds a legend that explains which values correspond to which levels.

Now let's add one more layer: a smooth curve displaying the relationship between body mass and flipper length. To do this, we'll use the **trendline** argument in Plotly to add a line of best fit based on a linear model.



```{python}
fig = px.scatter(
    penguins,
    x="flipper_length_mm",
    y="body_mass_g",
    color="species",
    trendline="ols",
    title="Scatterplot with Trendline of Flipper Length vs. Body Mass"
)

fig.show()
```


We have successfully added lines, but this plot shows separate lines for each of the penguin species. If we want a single line for the entire dataset instead, we can remove the color argument from the plot.


```{python}
scatter_fig = px.scatter(
    penguins,
    x="flipper_length_mm",
    y="body_mass_g",
    color="species",
)


fit = polyfit(penguins["flipper_length_mm"].dropna(), penguins["body_mass_g"].dropna(), 1)
trendline = fit[0] * penguins["flipper_length_mm"] + fit[1]


trendline_fig = go.Scatter(
    x=penguins["flipper_length_mm"],
    y=trendline,
    mode='lines',
    name='Trendline'
)


scatter_fig.add_trace(trendline_fig)


scatter_fig.show()
```


Voila! We have something that looks very much like our ultimate goal, though it's not yet perfect.

We still need to use different shapes for each species of penguins and improve labels.

It's generally not a good idea to represent information using only colors on a plot, as people perceive colors differently due to color blindness or other color vision differences. Therefore, in addition to color, we can also map `species` to the `shape` aesthetic.



```{python}
scatter_fig = px.scatter(
    penguins,
    x="flipper_length_mm",
    y="body_mass_g",
    color="species",
    symbol="species",
)


fit = polyfit(penguins["flipper_length_mm"].dropna(), penguins["body_mass_g"].dropna(), 1)
trendline = fit[0] * penguins["flipper_length_mm"] + fit[1]


trendline_fig = go.Scatter(
    x=penguins["flipper_length_mm"],
    y=trendline,
    mode='lines',
    name='Trendline'
)


scatter_fig.add_trace(trendline_fig)


scatter_fig.show()
```


Note that the legend is automatically updated to reflect the different shapes of the points as well.

And finally, we can improve the labels of our plot using the `labs()` function in a new layer. Some of the arguments to `labs()` might be self explanatory: `title` adds a title and `subtitle` adds a subtitle to the plot. Other arguments match the aesthetic mappings, `x` is the x-axis label, `y` is the y-axis label, and `color` and `shape` define the label for the legend.


```{python}
scatter_fig = px.scatter(
    penguins,
    x="flipper_length_mm",
    y="body_mass_g",
    color="species",
    symbol="species",
    title="Body mass and flipper length",
    labels={
        "flipper_length_mm": "Flipper length (mm)",
        "body_mass_g": "Body mass (g)",
        "species": "Species",
    }
)

scatter_fig.update_layout(
    title={
        'text': "Body mass and flipper length<br><sup>Dimensions for Adelie, Chinstrap, and Gentoo Penguins</sup>",
        'y':0.9,
        'x':0.5,
        'yanchor': 'top'
    }
)


fit = polyfit(penguins["flipper_length_mm"].dropna(), penguins["body_mass_g"].dropna(), 1)
trendline = fit[0] * penguins["flipper_length_mm"] + fit[1]


trendline_fig = go.Scatter(
    x=penguins["flipper_length_mm"],
    y=trendline,
    mode='lines',
    name='Trendline'
)


scatter_fig.add_trace(trendline_fig)


scatter_fig.show()
```


We finally have a plot that perfectly matches our "ultimate goal"!


### Exercises

1.  How many rows are in `penguins`?
    How many columns?

2.  What does the `bill_depth_mm` variable in the `penguins` data frame describe?
    Read the help for `?penguins` to find out.

3.  Make a scatterplot of `bill_depth_mm` vs. `bill_length_mm`.
    That is, make a scatterplot with `bill_depth_mm` on the y-axis and `bill_length_mm` on the x-axis.
    Describe the relationship between these two variables.

4.  What happens if you make a scatterplot of `species` vs. `bill_depth_mm`?
    What might be a better choice of geom?

5.  Why does the following give an error and how would you fix it?

    ```python
    fig = px.scatter(penguins x='bill_length_mm' y='bill_depth_mm')
    fig.show()
    ```

6.  Add the following caption to the plot you made in the previous exercise: "Data come from the palmerpenguins package." Hint: Take a look at the documentation for `labs()`.

7.  Recreate the following visualization. What aesthetic should bill_depth_mm be mapped to? And should it be mapped at the global level or at the geom level?



```{python}
from scipy.stats import linregress


scatter_fig = px.scatter(
    penguins,
    x="flipper_length_mm",
    y="body_mass_g",
    color="bill_depth_mm",
    color_continuous_scale=px.colors.sequential.Viridis
)


slope, intercept, r_value, p_value, std_err = linregress(penguins["flipper_length_mm"].dropna(), penguins["body_mass_g"].dropna())
trendline = slope * penguins["flipper_length_mm"] + intercept

trendline_fig = go.Scatter(
    x=penguins["flipper_length_mm"],
    y=trendline,
    mode='lines',
    name='Trendline',
    line=dict(color='red')
)


scatter_fig.add_trace(trendline_fig)

scatter_fig.show()
```


## A categorical variable

A variable is **categorical** if it can only take one of a small set of values.
To examine the distribution of a categorical variable, you can use a bar chart.
The height of the bars displays how many observations occurred with each `x` value.

```{python}
bar_fig = px.bar(
    penguins,
    x="species",
)

bar_fig.update_layout(
    plot_bgcolor='white',
    paper_bgcolor='white',
    xaxis=dict(showgrid=True, gridcolor='white'),
    yaxis=dict(showgrid=True, gridcolor='white')
)

bar_fig.show()
```


You may have seen earlier that the *data type* of the `"species"` column is string. Ideally, we want it to be categorical, so that there's no confusion about the fact that we're dealing with a finite number of mutually exclusive groups here. Another advantage is that it allows plotting tools to realise what kind of data it is working with.

We can transform the variable to a categorical variable using **pandas** like so:


```{python}
penguins["species"] = penguins["species"].astype("category")
penguins.head()
```

You will learn more about categorical variables later in the book.


### A numerical variable

A variable is **numerical** (or quantitative) if it can take on a wide range of numerical values, and it is sensible to add, subtract, or take averages with those values. Numerical variables can be continuous or discrete.

One commonly used visualisation for distributions of continuous variables is a histogram.


```{python}
hist_fig = px.histogram(
    penguins,
    x="body_mass_g"
)




hist_fig.show()
```


A histogram divides the x-axis into equally spaced bins and then uses the height of a bar to display the number of observations that fall in each bin.
In the graph above, the tallest bar shows that 39 observations have a `body_mass_g` value between 3,500 and 3,700 grams, which are the left and right edges of the bar.

You can set the width of the intervals in a histogram with the binwidth argument, which is measured in the units of the `x` variable.
You should always explore a variety of binwidths when working with histograms, as different binwidths can reveal different patterns.
In the plots below a binwidth of 20 is too narrow, resulting in too many bars, making it difficult to determine the shape of the distribution.
Similarly, a binwidth of 2,000 is too high, resulting in all data being binned into only three bars, and also making it difficult to determine the shape of the distribution.
A binwidth of 200 provides a sensible balance, but you should always look at your data a few different ways, especially with histograms as they can be misleading.


```{python}
from scipy.stats import gaussian_kde

body_mass = penguins['body_mass_g'].dropna()

density = gaussian_kde(body_mass)
x = np.linspace(body_mass.min(), body_mass.max(), 1000)
y = density(x)


fig = go.Figure()

fig.add_trace(go.Scatter(
    x=x,
    y=y,
    mode='lines',
    fill='tozeroy',
    name='Density'
))

fig.show()
```


### Exercises

1.  Make a bar plot of `"species"` of `penguins`, where you assign `"species"` to the `y` aesthetic.
    How is this plot different?
    
    ```Python
    import plotly.express as px
    fig = px.bar(penguins, x='species', y='count')
    fig.show()
    ```

2.  How are the following two plots different?
    Which aesthetic, `color` or `fill`, is more useful for changing the color of bars?

    ```Python
    fig1 = px.bar(penguins, x='species', color_discrete_sequence=['red'])
    fig1.show()

    fig2 = px.bar(penguins, x='species', color='species', color_discrete_map={'Adelie':'red', 'Chinstrap':'red', 'Gentoo':'red'})
    fig2.show()
    ```

3.  What does the `nbins` argument in `px.histogram()` do?

    ```Python
    fig = px.histogram(penguins, x='body_mass_g', nbins=30)
    fig.show()

    ```


## Visualising Relationships

To visualise a relationship we need to have at least two variables mapped to aesthetics of a plot—though you should remember that correlation is not causation, and causation is not correlation!

In the following sections you will learn about commonly used plots for visualising relationships between two or more variables and the geoms used for creating them.


A Numerical and a Categorical Variable
To visualize the relationship between a numerical and a categorical variable, we can use side-by-side box plots.

A boxplot is a type of visual shorthand for measures of position within a distribution (percentiles).

It is also useful for identifying potential outliers. Each boxplot consists of:

A box that indicates the range of the middle half of the data, a distance known as the interquartile range (IQR), stretching from the 25th percentile of the distribution to the 75th percentile.
In the middle of the box is a line that displays the median, i.e. the 50th percentile, of the distribution.
These three lines give you a sense of the spread of the distribution and whether or not the distribution is symmetric about the median or skewed to one side.

Visual points that display observations that fall more than 1.5 times the IQR from either edge of the box.
These outlying points are unusual, so they are plotted individually.

A line (or whisker) that extends from each end of the box and goes to the farthest non-outlier point in the distribution.

Let's take a look at the distribution of body mass by species using `px.box()`:



```{python}
fig = px.box(
    penguins,
    x="species",
    y="body_mass_g",
)


fig.show()
```

Alternatively, we can make probability density plots with `px.density_contour()`


```{python}
fig = go.Figure()

colors = {
    "Adelie": "red",
    "Chinstrap": "green",
    "Gentoo": "blue"
}

for species in penguins['species'].unique():
    species_data = penguins[penguins['species'] == species]['body_mass_g'].dropna()
    density = gaussian_kde(species_data)
    x = np.linspace(species_data.min(), species_data.max(), 1000)
    y = density(x)
    
    fig.add_trace(go.Scatter(
        x=x,
        y=y,
        mode='lines',
        fill='tozeroy',
        name= species,
        line=dict(color=colors[species], width=2)
    ))


fig.show()
```


Note the terminology we have used here:

-   We *map* variables to aesthetics if we want the visual attribute represented by that aesthetic to vary based on the values of that variable.
-   Otherwise, we *set* the value of an aesthetic.



### Two categorical variables

We can use stacked bar plots to visualise the relationship between two categorical variables.

For example, the following two stacked bar plots both display the relationship between `island` and `species`, or specifically, visualising the distribution of `species` within each island.

The first plot shows the frequencies of each species of penguins on each island.
The plot of frequencies show that there are equal numbers of Adelies on each island.

But we don't have a good sense of the percentage balance within each island.


```{python}
bar_fig = px.histogram(
    penguins,
    x="island",
    color="species"
)

bar_fig.update_layout(
    plot_bgcolor='white',
    paper_bgcolor='white',
    xaxis=dict(showgrid=True, gridcolor='lightgray'),
    yaxis=dict(showgrid=True, gridcolor='lightgray')
)

bar_fig.show()
```


The second plot is a relative frequency plot, created by setting `position = "fill"` in the geom is more useful for comparing species distributions across islands since it's not affected by the unequal numbers of penguins across the islands.

Using this plot we can see that Gentoo penguins all live on Biscoe island and make up roughly 75% of the penguins on that island, Chinstrap all live on Dream island and make up roughly 50% of the penguins on that island, and Adelie live on all three islands and make up all of the penguins on Torgersen.


```{python}
bar_fig = px.histogram(
    penguins,
    x="island",
    color="species",
    barnorm='percent'
)

bar_fig.update_layout(
    plot_bgcolor='white',
    paper_bgcolor='white',
    xaxis=dict(showgrid=True, gridcolor='lightgray'),
    yaxis=dict(showgrid=True, gridcolor='lightgray')
)

bar_fig.show()
```


### Two Numerical Variables
So far you've learned about scatterplots (created with `px.scatter()`) and smooth curves (created with `px.line()`) for visualizing the relationship between two numerical variables.
A scatterplot is probably the most commonly used plot for visualizing the relationship between two numerical variables.


```{python}
scatter_fig = px.scatter(
    penguins,
    x="flipper_length_mm",
    y="body_mass_g",
)

scatter_fig.show()
```



### Three or more variables

As we saw already, we can incorporate more variables into a plot by mapping them to additional aesthetics.

For example, in the following scatterplot the colors of points represent species and the shapes of points represent islands.



```{python}
scatter_fig = px.scatter(
    penguins,
    x="flipper_length_mm",
    y="body_mass_g",
    color="species",
    symbol="island"
)

scatter_fig.update_layout(
    legend=dict(
        tracegroupgap=10,
        itemsizing='constant',
        bgcolor='rgba(255, 255, 255, 0.5)',
        bordercolor='black',
        borderwidth=1,
    )
)

scatter_fig.show()
```






Adding too many aesthetic mappings to a plot can make it cluttered and difficult to understand.

Another way to handle this, especially for categorical variables, is to split your plot into facets (also known as small multiples), which are subplots that each display one subset of the data.

To facet your plot by a single variable in Plotly, you can use the `facet_col` or `facet_row` arguments in `px.scatter()`, `px.bar()`, or other Plotly Express functions.

The variable you pass to `facet_col` or facet_row should be categorical.



```{python}
scatter_fig = px.scatter(
    penguins,
    x="flipper_length_mm",
    y="body_mass_g",
    color="species",
    symbol="species",
    facet_col="island"
)

scatter_fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[-1]))


scatter_fig.show()
```


### Exercises


1. Make a scatterplot of bill_depth_mm vs. bill_length_mm and color the points by species.
What does adding coloring by species reveal about the relationship between these two variables?
What about faceting by species?

```Python
import plotly.express as px

# Scatterplot colored by species
fig = px.scatter(penguins, x='bill_length_mm', y='bill_depth_mm', color='species',
                 title='Scatterplot of Bill Depth vs. Bill Length Colored by Species')
fig.show()

# Scatterplot faceted by species
fig_facet = px.scatter(penguins, x='bill_length_mm', y='bill_depth_mm', color='species',
                       facet_col='species',
                       title='Scatterplot of Bill Depth vs. Bill Length Faceted by Species')
fig_facet.show()
```


2. Why does the following yield two separate legends?
How would you fix it to combine the two legends?


```Python
# This code will yield two separate legends in ggplot:
# ggplot(penguins, aes(x="bill_length_mm", y="bill_depth_mm", color="species", shape="species")) +
# geom_point() + labs(color="Species")

# In Plotly, we can achieve a combined legend by ensuring consistent mapping:
fig = px.scatter(penguins, x='bill_length_mm', y='bill_depth_mm', color='species', symbol='species',
                 title='Scatterplot with Combined Legend')
fig.update_layout(legend_title_text='Species')
fig.show()
```


3. Create the two following stacked bar plots.
Which question can you answer with the first one?
Which question can you answer with the second one?


```Python
# Stacked bar plot 1: island vs species
fig1 = px.bar(penguins, x='island', color='species', barmode='stack',
              title='Stacked Bar Plot: Island vs. Species')
fig1.show()

# Stacked bar plot 2: species vs island
fig2 = px.bar(penguins, x='species', color='island', barmode='stack',
              title='Stacked Bar Plot: Species vs. Island')
fig2.show()
```

In these exercises, you'll create scatterplots and stacked bar plots to explore the relationships between variables and visualize the data in different ways.




### Saving Plots

Once you've made a plot, you might want to save it as an image that you can use elsewhere.
In Plotly, you can use the `write_image()` function to save the plot to disk. This function is part of the `plotly.io module`:


```Python
import plotly.express as px
import plotly.io as pio

# Example plot
fig = px.scatter(penguins, x='bill_length_mm', y='bill_depth_mm', color='species',
                 title='Scatterplot of Bill Depth vs. Bill Length Colored by Species')

# Show the plot
fig.show()

# Save the plot to a file
pio.write_image(fig, 'scatterplot.png')
```

Make sure you have the kaleido package installed to save Plotly figures as static images:

```Python
pip install -U kaleido
```


### Exercises

1. Save the figure above as a PNG.



## Common Problems

As you start to run code, you're likely to run into problems. Don't worry—it happens to everyone. We have all been writing Python code for years, but every day we still write code that doesn't work on the first try!

Start by carefully comparing the code that you're running to the code in the book: A misplaced character can make all the difference! Make sure that every `(` is matched with a `)` and every `"` is paired with another `"`. In Visual Studio Code, you can get extensions that color match brackets so you can easily see if you closed them or not.

Sometimes you'll run the code and nothing happens.

For those coming from the R statistical programming language, you may be concerned about getting your `+` in the wrong place. Have no fear, however, as in the syntax for **Plotly**, the `+` is not required to add layers or elements to your plot.

If you're still stuck, try the help. You can get help about any Python function by running `help(function_name)` in the interactive window. Don't worry if the help doesn't seem that helpful - instead, skip down to the examples and look for code that matches what you're trying to do.

If you're still stuck, check out the **Plotly** [documentation](https://plotly.com/python/) or do a Google search (especially helpful for error messages).



## Summary
In this chapter, you've learned the basics of data visualization with **Plotly**. We started with the basic idea that underpins **Plotly**: a visualization is a mapping from variables in your data to aesthetic properties like position, color, size, and shape. You then learned about increasing the complexity and improving the presentation of your plots layer-by-layer. You also learned about commonly used plots for visualizing the distribution of a single variable as well as for visualizing relationships between two or more variables, by leveraging additional aesthetic mappings and/or splitting your plot into small multiples using faceting.

We'll use visualizations again and again throughout this book, introducing new techniques as we need them as well as doing a deeper dive into creating visualizations with **Plotly** in subsequent chapters.

With the basics of visualization under your belt, in the next chapter we're going to switch gears a little and give you some practical workflow advice. We intersperse workflow advice with data science tools throughout this part of the book because it'll help you stay organized as you write more Python code.




